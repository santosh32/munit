/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.munit;

import org.mule.MessageExchangePattern;
import org.mule.api.MuleContext;
import org.mule.api.MuleEvent;
import org.mule.api.NestedProcessor;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Optional;
import org.mule.api.config.MuleProperties;
import org.mule.api.context.MuleContextAware;
import org.mule.api.el.ExpressionLanguageContext;
import org.mule.api.el.ExpressionLanguageExtension;
import org.mule.api.processor.MessageProcessor;
import org.mule.construct.Flow;
import org.mule.munit.common.endpoint.MockEndpointManager;
import org.mule.munit.common.endpoint.OutboundBehavior;
import org.mule.munit.common.mp.MessageProcessorCall;
import org.mule.munit.common.mp.MockedMessageProcessorBehavior;
import org.mule.munit.common.mp.MockedMessageProcessorManager;
import org.mule.munit.common.mp.SpyAssertion;
import org.mule.munit.functions.*;
import org.mule.tck.MuleTestUtils;

import java.util.*;

import static junit.framework.Assert.fail;

/**
 * Generic module
 *
 * @author MuleSoft, Inc.
 */
@Module(name="mock", schemaVersion="3.3")
public class MockModule implements MuleContextAware, ExpressionLanguageExtension
{
    private MuleContext muleContext;


    /**
     * <p>Define what the mock must return on a message processor call.</p>
     * <p/>
     * <p>If the message processor doesn't return any value then there is no need to define an expect.</p>
     * <p/>
     * <p>You can define the message processor parameters in the same order they appear in the API documentation. In
     * order to define the behaviour on that particular case.</p>
     * <p/>
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:expect}
     *
     * @param messageProcessor Message processor name.
     * @param toReturn             Expected return value.
     * @param attributes           Message processor parameters.
     */
    @Processor
    public void expect(String messageProcessor,
                       MunitMuleMessage toReturn,
                       @Optional List<Attribute> attributes) {
        try {
            MockedMessageProcessorManager manager = getManager();
            manager.addBehavior(new MockedMessageProcessorBehavior(getName(messageProcessor),
                    getNamespace(messageProcessor), createAttributes(attributes), toReturn.getPayload()));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * <p>Define what the mock must return on a message processor call.</p>
     * <p/>
     * <p>If the message processor doesn't return any value then there is no need to define an expect.</p>
     * <p/>
     * <p>You can define the message processor parameters in the same order they appear in the API documentation. In
     * order to define the behaviour on that particular case.</p>
     * <p/>
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:spy}
     *
     * @param messageProcessor Message processor name.
     * @param assertionsBeforeCall Expected return value.
     * @param assertionsAfterCall  Message processor parameters.
     */
    @Processor
    public void spy(String messageProcessor,
                    @Optional List<NestedProcessor> assertionsBeforeCall,
                    @Optional List<NestedProcessor> assertionsAfterCall) {
            getManager().addSpyAssertion(messageProcessor,
                    new SpyAssertion(createMessageProcessorsFrom(assertionsBeforeCall),
                            createMessageProcessorsFrom(assertionsAfterCall)));
    }


    private Map<String, Object> createAttributes(List<Attribute> attributes) {
        Map<String, Object> attrs = new HashMap<String, Object>();
        if ( attributes == null ){
            return attrs;
        }

        for ( Attribute attr : attributes ){
            attrs.put(attr.getName(), attr.getWhereValue());
        }

        return attrs;
    }

    private String getNamespace(String when) {
        String[] split = when.split(":");
        if (split.length > 1) {
            return split[0];
        }

        return "mule";
    }

    private String getName(String when) {
        String[] split = when.split(":");
        if (split.length > 1) {
            return split[1];
        }

        return split[0];
    }


    /**
     * <p>Expect to throw an exception when message processor is called. </p>
     * <p/>
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:expectFail}
     *
     * @param throwA Java Exception full qualified name.
     * @param when   Message processor name.
     */
//    @Processor
    public void expectFail(String when, String throwA) {
    }


    /**
     * Check that the message processor was called with some specified parameters
     * <p/>
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:verifyCall}
     *
     * @param messageProcessor Message processor Id
     * @param attributes       Message processor parameters.
     * @param times            Number of times the message processor has to be called
     * @param atLeast          Number of time the message processor has to be called at least.
     * @param atMost           Number of times the message processor has to be called at most.
     */
    @Processor
    public void verifyCall(String messageProcessor, @Optional List<Attribute> attributes,
                           @Optional Integer times,
                           @Optional Integer atLeast, @Optional Integer atMost) {
        List<MessageProcessorCall> executedCalls = getManager().findCallsFor(getName(messageProcessor), getNamespace(messageProcessor), createAttributes(attributes));


        if (times != null) {
            if (executedCalls.size() != times) {
                fail("On " + messageProcessor + ".Expected " + times + " but got " + executedCalls.size() + " calls");
            }
        } else if (atLeast != null) {
            if (executedCalls.size() < atLeast) {
                fail("On " + messageProcessor + ".Expected at least " + atLeast + " but got " + executedCalls.size() + " calls");
            }
        } else if (atMost != null) {
            if (executedCalls.size() > atMost) {
                fail("On " + messageProcessor + ".Expected at least " + atMost + " but got " + executedCalls.size() + " calls");
            }
        } else {

            if (executedCalls.isEmpty()) {
                fail("On " + messageProcessor + ".It was never called");
            }
        }

    }


    @Override
    public void setMuleContext(MuleContext muleContext) {
        this.muleContext = muleContext;
    }



    /**
     * Reset mock behaviour
     *
     * {@sample.xml ../../../doc/mock-connector.xml.sample mock:outboundEndpoint}
     *
     * @param address the address
     * @param returnPayload the Return Payload
     * @param returnInboundProperties inbound properties
     * @param returnInvocationProperties invocation properties
     * @param returnSessionProperties invocation session properties
     * @param returnOutboundProperties oubound properties
     * @param assertions assertions
     */
    @Processor
    public void outboundEndpoint(String address,
                                 @Optional Object returnPayload,
                                 @Optional Map<String, Object> returnInvocationProperties,
                                 @Optional Map<String, Object> returnInboundProperties,
                                 @Optional Map<String, Object> returnSessionProperties,
                                 @Optional Map<String, Object> returnOutboundProperties,
                                 @Optional List<NestedProcessor> assertions) {

        MockEndpointManager factory = (MockEndpointManager) muleContext.getRegistry().lookupObject(MuleProperties.OBJECT_MULE_ENDPOINT_FACTORY);

        OutboundBehavior behavior = new OutboundBehavior(returnPayload, createMessageProcessorsFrom(assertions));

        behavior.setInboundProperties(returnInboundProperties);
        behavior.setInvocationProperties(returnInvocationProperties);
        behavior.setOutboundProperties(returnOutboundProperties);
        behavior.setSessionProperties(returnSessionProperties);

        factory.addExpect(address, behavior);
    }

    private List<MessageProcessor> createMessageProcessorsFrom(List<NestedProcessor> assertions) {
        if (assertions == null) {
            return null;
        }


        List<MessageProcessor> mps = new ArrayList<MessageProcessor>();
        for (NestedProcessor nestedProcessor : assertions) {
            mps.add(new NestedMessageProcessor(nestedProcessor));
        }

        return mps;
    }


    private Object getResultOf(String mustReturnResponseFrom) {

        try {
            Flow flow = (Flow) muleContext.getRegistry().lookupFlowConstruct(mustReturnResponseFrom);
            if (flow == null) {
                throw new RuntimeException("Flow " + mustReturnResponseFrom + " does not exist");
            }

            MuleEvent process = flow.process(testEvent());
            return process.getMessage().getPayload();
        } catch (Exception e) {
            throw new RuntimeException("Could not call flow " + mustReturnResponseFrom + " to get the expected result");
        }
    }

    private MuleEvent testEvent() throws Exception {
        return MuleTestUtils.getTestEvent(null, MessageExchangePattern.REQUEST_RESPONSE, muleContext);
    }

    @Override
    public void configureContext(ExpressionLanguageContext context) {
        context.declareFunction("eq", new EqMatcherFunction());
        context.declareFunction("anyBoolean", new AnyMatcherFunction(Boolean.class));
        context.declareFunction("anyByte", new AnyMatcherFunction(Byte.class));
        context.declareFunction("anyInt", new AnyMatcherFunction(Integer.class));
        context.declareFunction("anyDouble", new AnyMatcherFunction(Double.class));
        context.declareFunction("anyFloat", new AnyMatcherFunction(Float.class));
        context.declareFunction("anyShort", new AnyMatcherFunction(Short.class));
        context.declareFunction("anyObject", new AnyMatcherFunction(Object.class));
        context.declareFunction("anyString", new AnyMatcherFunction(String.class));
        context.declareFunction("anyList", new AnyMatcherFunction(List.class));
        context.declareFunction("anySet", new AnyMatcherFunction(Set.class));
        context.declareFunction("anyMap", new AnyMatcherFunction(Map.class));
        context.declareFunction("anyCollection", new AnyMatcherFunction(Collection.class));
        context.declareFunction("isNull", new NullMatcherFunction());
        context.declareFunction("isNotNull", new NotNullMatcherFunction());
        context.declareFunction("any", new AnyClassMatcherFunction());
        context.declareFunction("resultOfScript", new FlowResultFunction(muleContext));
    }

    private MockedMessageProcessorManager getManager() {
        return (MockedMessageProcessorManager) muleContext.getRegistry().lookupObject(MockedMessageProcessorManager.ID);
    }

}
